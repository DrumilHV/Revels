{"ast":null,"code":"class e {\n  constructor(a, b, c, d, f) {\n    this._legacyCanvasSize = e.DEFAULT_CANVAS_SIZE;\n    this._preferredCamera = \"environment\";\n    this._maxScansPerSecond = 25;\n    this._lastScanTimestamp = -1;\n    this._destroyed = this._flashOn = this._paused = this._active = !1;\n    this.$video = a;\n    this.$canvas = document.createElement(\"canvas\");\n    c && \"object\" === typeof c ? this._onDecode = b : (c || d || f ? console.warn(\"You're using a deprecated version of the QrScanner constructor which will be removed in the future\") : console.warn(\"Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\"), this._legacyOnDecode = b);\n    b = \"object\" === typeof c ? c : {};\n    this._onDecodeError = b.onDecodeError || (\"function\" === typeof c ? c : this._onDecodeError);\n    this._calculateScanRegion = b.calculateScanRegion || (\"function\" === typeof d ? d : this._calculateScanRegion);\n    this._preferredCamera = b.preferredCamera || f || this._preferredCamera;\n    this._legacyCanvasSize = \"number\" === typeof c ? c : \"number\" === typeof d ? d : this._legacyCanvasSize;\n    this._maxScansPerSecond = b.maxScansPerSecond || this._maxScansPerSecond;\n    this._onPlay = this._onPlay.bind(this);\n    this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n    this._onVisibilityChange = this._onVisibilityChange.bind(this);\n    this._updateOverlay = this._updateOverlay.bind(this);\n    a.disablePictureInPicture = !0;\n    a.playsInline = !0;\n    a.muted = !0;\n    let h = !1;\n    a.hidden && (a.hidden = !1, h = !0);\n    document.body.contains(a) || (document.body.appendChild(a), h = !0);\n    c = a.parentElement;\n    if (b.highlightScanRegion || b.highlightCodeOutline) {\n      d = !!b.overlay;\n      this.$overlay = b.overlay || document.createElement(\"div\");\n      f = this.$overlay.style;\n      f.position = \"absolute\";\n      f.display = \"none\";\n      f.pointerEvents = \"none\";\n      this.$overlay.classList.add(\"scan-region-highlight\");\n      if (!d && b.highlightScanRegion) {\n        this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\"><path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21\"/></svg>';\n        try {\n          this.$overlay.firstElementChild.animate({\n            transform: [\"scale(.98)\", \"scale(1.01)\"]\n          }, {\n            duration: 400,\n            iterations: Infinity,\n            direction: \"alternate\",\n            easing: \"ease-in-out\"\n          });\n        } catch (m) {}\n        c.insertBefore(this.$overlay, this.$video.nextSibling);\n      }\n      b.highlightCodeOutline && (this.$overlay.insertAdjacentHTML(\"beforeend\", '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>'), this.$codeOutlineHighlight = this.$overlay.lastElementChild);\n    }\n    this._scanRegion = this._calculateScanRegion(a);\n    requestAnimationFrame(() => {\n      let m = window.getComputedStyle(a);\n      \"none\" === m.display && (a.style.setProperty(\"display\", \"block\", \"important\"), h = !0);\n      \"visible\" !== m.visibility && (a.style.setProperty(\"visibility\", \"visible\", \"important\"), h = !0);\n      h && (console.warn(\"QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.\"), a.style.opacity = \"0\", a.style.width = \"0\", a.style.height = \"0\", this.$overlay && this.$overlay.parentElement && this.$overlay.parentElement.removeChild(this.$overlay), delete this.$overlay, delete this.$codeOutlineHighlight);\n      this.$overlay && this._updateOverlay();\n    });\n    a.addEventListener(\"play\", this._onPlay);\n    a.addEventListener(\"loadedmetadata\", this._onLoadedMetaData);\n    document.addEventListener(\"visibilitychange\", this._onVisibilityChange);\n    window.addEventListener(\"resize\", this._updateOverlay);\n    this._qrEnginePromise = e.createQrEngine();\n  }\n  static set WORKER_PATH(a) {\n    console.warn(\"Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.\");\n  }\n  static async hasCamera() {\n    try {\n      return !!(await e.listCameras(!1)).length;\n    } catch (a) {\n      return !1;\n    }\n  }\n  static async listCameras() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n    if (!navigator.mediaDevices) return [];\n    let b = async () => (await navigator.mediaDevices.enumerateDevices()).filter(d => \"videoinput\" === d.kind),\n      c;\n    try {\n      a && (await b()).every(d => !d.label) && (c = await navigator.mediaDevices.getUserMedia({\n        audio: !1,\n        video: !0\n      }));\n    } catch (d) {}\n    try {\n      return (await b()).map((d, f) => ({\n        id: d.deviceId,\n        label: d.label || (0 === f ? \"Default Camera\" : \"Camera \".concat(f + 1))\n      }));\n    } finally {\n      c && (console.warn(\"Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream\"), e._stopVideoStream(c));\n    }\n  }\n  async hasFlash() {\n    let a;\n    try {\n      if (this.$video.srcObject) {\n        if (!(this.$video.srcObject instanceof MediaStream)) return !1;\n        a = this.$video.srcObject;\n      } else a = (await this._getCameraStream()).stream;\n      return \"torch\" in a.getVideoTracks()[0].getSettings();\n    } catch (b) {\n      return !1;\n    } finally {\n      a && a !== this.$video.srcObject && (console.warn(\"Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream\"), e._stopVideoStream(a));\n    }\n  }\n  isFlashOn() {\n    return this._flashOn;\n  }\n  async toggleFlash() {\n    this._flashOn ? await this.turnFlashOff() : await this.turnFlashOn();\n  }\n  async turnFlashOn() {\n    if (!this._flashOn && !this._destroyed && (this._flashOn = !0, this._active && !this._paused)) try {\n      if (!(await this.hasFlash())) throw \"No flash available\";\n      await this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n        advanced: [{\n          torch: !0\n        }]\n      });\n    } catch (a) {\n      throw this._flashOn = !1, a;\n    }\n  }\n  async turnFlashOff() {\n    this._flashOn && (this._flashOn = !1, await this._restartVideoStream());\n  }\n  destroy() {\n    this.$video.removeEventListener(\"loadedmetadata\", this._onLoadedMetaData);\n    this.$video.removeEventListener(\"play\", this._onPlay);\n    document.removeEventListener(\"visibilitychange\", this._onVisibilityChange);\n    window.removeEventListener(\"resize\", this._updateOverlay);\n    this._destroyed = !0;\n    this._flashOn = !1;\n    this.stop();\n    e._postWorkerMessage(this._qrEnginePromise, \"close\");\n  }\n  async start() {\n    if (this._destroyed) throw Error(\"The QR scanner can not be started as it had been destroyed.\");\n    if (!this._active || this._paused) if (\"https:\" !== window.location.protocol && console.warn(\"The camera stream is only accessible if the page is transferred via https.\"), this._active = !0, !document.hidden) if (this._paused = !1, this.$video.srcObject) await this.$video.play();else try {\n      let {\n        stream: a,\n        facingMode: b\n      } = await this._getCameraStream();\n      !this._active || this._paused ? e._stopVideoStream(a) : (this._setVideoMirror(b), this.$video.srcObject = a, await this.$video.play(), this._flashOn && (this._flashOn = !1, this.turnFlashOn().catch(() => {})));\n    } catch (a) {\n      if (!this._paused) throw this._active = !1, a;\n    }\n  }\n  stop() {\n    this.pause();\n    this._active = !1;\n  }\n  async pause() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n    this._paused = !0;\n    if (!this._active) return !0;\n    this.$video.pause();\n    this.$overlay && (this.$overlay.style.display = \"none\");\n    let b = () => {\n      this.$video.srcObject instanceof MediaStream && (e._stopVideoStream(this.$video.srcObject), this.$video.srcObject = null);\n    };\n    if (a) return b(), !0;\n    await new Promise(c => setTimeout(c, 300));\n    if (!this._paused) return !1;\n    b();\n    return !0;\n  }\n  async setCamera(a) {\n    a !== this._preferredCamera && (this._preferredCamera = a, await this._restartVideoStream());\n  }\n  static async scanImage(a, b, c, d) {\n    let f = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n    let h = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;\n    let m,\n      n = !1;\n    b && (\"scanRegion\" in b || \"qrEngine\" in b || \"canvas\" in b || \"disallowCanvasResizing\" in b || \"alsoTryWithoutScanRegion\" in b || \"returnDetailedScanResult\" in b) ? (m = b.scanRegion, c = b.qrEngine, d = b.canvas, f = b.disallowCanvasResizing || !1, h = b.alsoTryWithoutScanRegion || !1, n = !0) : b || c || d || f || h ? console.warn(\"You're using a deprecated api for scanImage which will be removed in the future.\") : console.warn(\"Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\");\n    b = !!c;\n    try {\n      let p, k;\n      [c, p] = await Promise.all([c || e.createQrEngine(), e._loadImage(a)]);\n      [d, k] = e._drawToCanvas(p, m, d, f);\n      let q;\n      if (c instanceof Worker) {\n        let g = c;\n        b || e._postWorkerMessageSync(g, \"inversionMode\", \"both\");\n        q = await new Promise((l, v) => {\n          let w,\n            u,\n            r,\n            y = -1;\n          u = t => {\n            t.data.id === y && (g.removeEventListener(\"message\", u), g.removeEventListener(\"error\", r), clearTimeout(w), null !== t.data.data ? l({\n              data: t.data.data,\n              cornerPoints: e._convertPoints(t.data.cornerPoints, m)\n            }) : v(e.NO_QR_CODE_FOUND));\n          };\n          r = t => {\n            g.removeEventListener(\"message\", u);\n            g.removeEventListener(\"error\", r);\n            clearTimeout(w);\n            v(\"Scanner error: \" + (t ? t.message || t : \"Unknown Error\"));\n          };\n          g.addEventListener(\"message\", u);\n          g.addEventListener(\"error\", r);\n          w = setTimeout(() => r(\"timeout\"), 1E4);\n          let x = k.getImageData(0, 0, d.width, d.height);\n          y = e._postWorkerMessageSync(g, \"decode\", x, [x.data.buffer]);\n        });\n      } else q = await Promise.race([new Promise((g, l) => window.setTimeout(() => l(\"Scanner error: timeout\"), 1E4)), (async () => {\n        try {\n          var [g] = await c.detect(d);\n          if (!g) throw e.NO_QR_CODE_FOUND;\n          return {\n            data: g.rawValue,\n            cornerPoints: e._convertPoints(g.cornerPoints, m)\n          };\n        } catch (l) {\n          g = l.message || l;\n          if (/not implemented|service unavailable/.test(g)) return e._disableBarcodeDetector = !0, e.scanImage(a, {\n            scanRegion: m,\n            canvas: d,\n            disallowCanvasResizing: f,\n            alsoTryWithoutScanRegion: h\n          });\n          throw \"Scanner error: \".concat(g);\n        }\n      })()]);\n      return n ? q : q.data;\n    } catch (p) {\n      if (!m || !h) throw p;\n      let k = await e.scanImage(a, {\n        qrEngine: c,\n        canvas: d,\n        disallowCanvasResizing: f\n      });\n      return n ? k : k.data;\n    } finally {\n      b || e._postWorkerMessage(c, \"close\");\n    }\n  }\n  setGrayscaleWeights(a, b, c) {\n    let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n    e._postWorkerMessage(this._qrEnginePromise, \"grayscaleWeights\", {\n      red: a,\n      green: b,\n      blue: c,\n      useIntegerApproximation: d\n    });\n  }\n  setInversionMode(a) {\n    e._postWorkerMessage(this._qrEnginePromise, \"inversionMode\", a);\n  }\n  static async createQrEngine(a) {\n    a && console.warn(\"Specifying a worker path is not required and not supported anymore.\");\n    a = () => import(\"./qr-scanner-worker.min.js\").then(c => c.createWorker());\n    if (!(!e._disableBarcodeDetector && \"BarcodeDetector\" in window && BarcodeDetector.getSupportedFormats && (await BarcodeDetector.getSupportedFormats()).includes(\"qr_code\"))) return a();\n    let b = navigator.userAgentData;\n    return b && b.brands.some(_ref => {\n      let {\n        brand: c\n      } = _ref;\n      return /Chromium/i.test(c);\n    }) && /mac ?OS/i.test(b.platform) && (await b.getHighEntropyValues([\"architecture\", \"platformVersion\"]).then(_ref2 => {\n      let {\n        architecture: c,\n        platformVersion: d\n      } = _ref2;\n      return /arm/i.test(c || \"arm\") && 13 <= parseInt(d || \"13\");\n    }).catch(() => !0)) ? a() : new BarcodeDetector({\n      formats: [\"qr_code\"]\n    });\n  }\n  _onPlay() {\n    this._scanRegion = this._calculateScanRegion(this.$video);\n    this._updateOverlay();\n    this.$overlay && (this.$overlay.style.display = \"\");\n    this._scanFrame();\n  }\n  _onLoadedMetaData() {\n    this._scanRegion = this._calculateScanRegion(this.$video);\n    this._updateOverlay();\n  }\n  _onVisibilityChange() {\n    document.hidden ? this.pause() : this._active && this.start();\n  }\n  _calculateScanRegion(a) {\n    let b = Math.round(2 / 3 * Math.min(a.videoWidth, a.videoHeight));\n    return {\n      x: Math.round((a.videoWidth - b) / 2),\n      y: Math.round((a.videoHeight - b) / 2),\n      width: b,\n      height: b,\n      downScaledWidth: this._legacyCanvasSize,\n      downScaledHeight: this._legacyCanvasSize\n    };\n  }\n  _updateOverlay() {\n    requestAnimationFrame(() => {\n      if (this.$overlay) {\n        var a = this.$video,\n          b = a.videoWidth,\n          c = a.videoHeight,\n          d = a.offsetWidth,\n          f = a.offsetHeight,\n          h = a.offsetLeft,\n          m = a.offsetTop,\n          n = window.getComputedStyle(a),\n          p = n.objectFit,\n          k = b / c,\n          q = d / f;\n        switch (p) {\n          case \"none\":\n            var g = b;\n            var l = c;\n            break;\n          case \"fill\":\n            g = d;\n            l = f;\n            break;\n          default:\n            (\"cover\" === p ? k > q : k < q) ? (l = f, g = l * k) : (g = d, l = g / k), \"scale-down\" === p && (g = Math.min(g, b), l = Math.min(l, c));\n        }\n        var [v, w] = n.objectPosition.split(\" \").map((r, y) => {\n          const x = parseFloat(r);\n          return r.endsWith(\"%\") ? (y ? f - l : d - g) * x / 100 : x;\n        });\n        n = this._scanRegion.width || b;\n        q = this._scanRegion.height || c;\n        p = this._scanRegion.x || 0;\n        var u = this._scanRegion.y || 0;\n        k = this.$overlay.style;\n        k.width = \"\".concat(n / b * g, \"px\");\n        k.height = \"\".concat(q / c * l, \"px\");\n        k.top = \"\".concat(m + w + u / c * l, \"px\");\n        c = /scaleX\\(-1\\)/.test(a.style.transform);\n        k.left = \"\".concat(h + (c ? d - v - g : v) + (c ? b - p - n : p) / b * g, \"px\");\n        k.transform = a.style.transform;\n      }\n    });\n  }\n  static _convertPoints(a, b) {\n    if (!b) return a;\n    let c = b.x || 0,\n      d = b.y || 0,\n      f = b.width && b.downScaledWidth ? b.width / b.downScaledWidth : 1;\n    b = b.height && b.downScaledHeight ? b.height / b.downScaledHeight : 1;\n    for (let h of a) h.x = h.x * f + c, h.y = h.y * b + d;\n    return a;\n  }\n  _scanFrame() {\n    !this._active || this.$video.paused || this.$video.ended || (\"requestVideoFrameCallback\" in this.$video ? this.$video.requestVideoFrameCallback.bind(this.$video) : requestAnimationFrame)(async () => {\n      if (!(1 >= this.$video.readyState)) {\n        var a = Date.now() - this._lastScanTimestamp,\n          b = 1E3 / this._maxScansPerSecond;\n        a < b && (await new Promise(d => setTimeout(d, b - a)));\n        this._lastScanTimestamp = Date.now();\n        try {\n          var c = await e.scanImage(this.$video, {\n            scanRegion: this._scanRegion,\n            qrEngine: this._qrEnginePromise,\n            canvas: this.$canvas\n          });\n        } catch (d) {\n          if (!this._active) return;\n          this._onDecodeError(d);\n        }\n        !e._disableBarcodeDetector || (await this._qrEnginePromise) instanceof Worker || (this._qrEnginePromise = e.createQrEngine());\n        c ? (this._onDecode ? this._onDecode(c) : this._legacyOnDecode && this._legacyOnDecode(c.data), this.$codeOutlineHighlight && (clearTimeout(this._codeOutlineHighlightRemovalTimeout), this._codeOutlineHighlightRemovalTimeout = void 0, this.$codeOutlineHighlight.setAttribute(\"viewBox\", \"\".concat(this._scanRegion.x || 0, \" \") + \"\".concat(this._scanRegion.y || 0, \" \") + \"\".concat(this._scanRegion.width || this.$video.videoWidth, \" \") + \"\".concat(this._scanRegion.height || this.$video.videoHeight)), this.$codeOutlineHighlight.firstElementChild.setAttribute(\"points\", c.cornerPoints.map(_ref3 => {\n          let {\n            x: d,\n            y: f\n          } = _ref3;\n          return \"\".concat(d, \",\").concat(f);\n        }).join(\" \")), this.$codeOutlineHighlight.style.display = \"\")) : this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout && (this._codeOutlineHighlightRemovalTimeout = setTimeout(() => this.$codeOutlineHighlight.style.display = \"none\", 100));\n      }\n      this._scanFrame();\n    });\n  }\n  _onDecodeError(a) {\n    a !== e.NO_QR_CODE_FOUND && console.log(a);\n  }\n  async _getCameraStream() {\n    if (!navigator.mediaDevices) throw \"Camera not found.\";\n    let a = /^(environment|user)$/.test(this._preferredCamera) ? \"facingMode\" : \"deviceId\",\n      b = [{\n        width: {\n          min: 1024\n        }\n      }, {\n        width: {\n          min: 768\n        }\n      }, {}],\n      c = b.map(d => Object.assign({}, d, {\n        [a]: {\n          exact: this._preferredCamera\n        }\n      }));\n    for (let d of [...c, ...b]) try {\n      let f = await navigator.mediaDevices.getUserMedia({\n          video: d,\n          audio: !1\n        }),\n        h = this._getFacingMode(f) || (d.facingMode ? this._preferredCamera : \"environment\" === this._preferredCamera ? \"user\" : \"environment\");\n      return {\n        stream: f,\n        facingMode: h\n      };\n    } catch (f) {}\n    throw \"Camera not found.\";\n  }\n  async _restartVideoStream() {\n    let a = this._paused;\n    (await this.pause(!0)) && !a && this._active && (await this.start());\n  }\n  static _stopVideoStream(a) {\n    for (let b of a.getTracks()) b.stop(), a.removeTrack(b);\n  }\n  _setVideoMirror(a) {\n    this.$video.style.transform = \"scaleX(\" + (\"user\" === a ? -1 : 1) + \")\";\n  }\n  _getFacingMode(a) {\n    return (a = a.getVideoTracks()[0]) ? /rear|back|environment/i.test(a.label) ? \"environment\" : /front|user|face/i.test(a.label) ? \"user\" : null : null;\n  }\n  static _drawToCanvas(a, b, c) {\n    let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n    c = c || document.createElement(\"canvas\");\n    let f = b && b.x ? b.x : 0,\n      h = b && b.y ? b.y : 0,\n      m = b && b.width ? b.width : a.videoWidth || a.width,\n      n = b && b.height ? b.height : a.videoHeight || a.height;\n    d || (d = b && b.downScaledWidth ? b.downScaledWidth : m, b = b && b.downScaledHeight ? b.downScaledHeight : n, c.width !== d && (c.width = d), c.height !== b && (c.height = b));\n    b = c.getContext(\"2d\", {\n      alpha: !1\n    });\n    b.imageSmoothingEnabled = !1;\n    b.drawImage(a, f, h, m, n, 0, 0, c.width, c.height);\n    return [c, b];\n  }\n  static async _loadImage(a) {\n    if (a instanceof Image) return await e._awaitImageLoad(a), a;\n    if (a instanceof HTMLVideoElement || a instanceof HTMLCanvasElement || a instanceof SVGImageElement || \"OffscreenCanvas\" in window && a instanceof OffscreenCanvas || \"ImageBitmap\" in window && a instanceof ImageBitmap) return a;\n    if (a instanceof File || a instanceof Blob || a instanceof URL || \"string\" === typeof a) {\n      let b = new Image();\n      b.src = a instanceof File || a instanceof Blob ? URL.createObjectURL(a) : a.toString();\n      try {\n        return await e._awaitImageLoad(b), b;\n      } finally {\n        (a instanceof File || a instanceof Blob) && URL.revokeObjectURL(b.src);\n      }\n    } else throw \"Unsupported image type.\";\n  }\n  static async _awaitImageLoad(a) {\n    a.complete && 0 !== a.naturalWidth || (await new Promise((b, c) => {\n      let d = f => {\n        a.removeEventListener(\"load\", d);\n        a.removeEventListener(\"error\", d);\n        f instanceof ErrorEvent ? c(\"Image load error\") : b();\n      };\n      a.addEventListener(\"load\", d);\n      a.addEventListener(\"error\", d);\n    }));\n  }\n  static async _postWorkerMessage(a, b, c, d) {\n    return e._postWorkerMessageSync(await a, b, c, d);\n  }\n  static _postWorkerMessageSync(a, b, c, d) {\n    if (!(a instanceof Worker)) return -1;\n    let f = e._workerMessageId++;\n    a.postMessage({\n      id: f,\n      type: b,\n      data: c\n    }, d);\n    return f;\n  }\n}\ne.DEFAULT_CANVAS_SIZE = 400;\ne.NO_QR_CODE_FOUND = \"No QR code found\";\ne._disableBarcodeDetector = !1;\ne._workerMessageId = 0;\nexport default e;","map":{"version":3,"names":["constructor","a","b","c","d","f","_legacyCanvasSize","e","DEFAULT_CANVAS_SIZE","_preferredCamera","_maxScansPerSecond","_lastScanTimestamp","_destroyed","_flashOn","_paused","_active","$video","$canvas","document","createElement","_onDecode","console","warn","_legacyOnDecode","_onDecodeError","onDecodeError","_calculateScanRegion","calculateScanRegion","preferredCamera","maxScansPerSecond","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","_updateOverlay","disablePictureInPicture","playsInline","muted","h","hidden","body","contains","appendChild","parentElement","highlightScanRegion","highlightCodeOutline","overlay","$overlay","style","position","display","pointerEvents","classList","add","innerHTML","firstElementChild","animate","transform","duration","iterations","Infinity","direction","easing","m","insertBefore","nextSibling","insertAdjacentHTML","$codeOutlineHighlight","lastElementChild","_scanRegion","requestAnimationFrame","window","getComputedStyle","setProperty","visibility","opacity","width","height","removeChild","addEventListener","_qrEnginePromise","createQrEngine","WORKER_PATH","hasCamera","listCameras","length","arguments","undefined","navigator","mediaDevices","enumerateDevices","filter","kind","every","label","getUserMedia","audio","video","map","id","deviceId","concat","_stopVideoStream","hasFlash","srcObject","MediaStream","_getCameraStream","stream","getVideoTracks","getSettings","isFlashOn","toggleFlash","turnFlashOff","turnFlashOn","applyConstraints","advanced","torch","_restartVideoStream","destroy","removeEventListener","stop","_postWorkerMessage","start","Error","location","protocol","play","facingMode","_setVideoMirror","catch","pause","Promise","setTimeout","setCamera","scanImage","n","scanRegion","qrEngine","canvas","disallowCanvasResizing","alsoTryWithoutScanRegion","p","k","all","_loadImage","_drawToCanvas","q","Worker","g","_postWorkerMessageSync","l","v","w","u","r","y","t","data","clearTimeout","cornerPoints","_convertPoints","NO_QR_CODE_FOUND","x","getImageData","buffer","race","detect","rawValue","message","test","_disableBarcodeDetector","setGrayscaleWeights","red","green","blue","useIntegerApproximation","setInversionMode","then","createWorker","BarcodeDetector","getSupportedFormats","includes","userAgentData","brands","some","_ref","brand","platform","getHighEntropyValues","_ref2","architecture","platformVersion","parseInt","formats","_scanFrame","Math","round","min","videoWidth","videoHeight","downScaledWidth","downScaledHeight","offsetWidth","offsetHeight","offsetLeft","objectFit","objectPosition","split","parseFloat","endsWith","top","left","paused","ended","requestVideoFrameCallback","readyState","Date","now","_codeOutlineHighlightRemovalTimeout","setAttribute","_ref3","join","log","Object","assign","exact","_getFacingMode","getTracks","removeTrack","getContext","alpha","imageSmoothingEnabled","drawImage","Image","_awaitImageLoad","HTMLVideoElement","HTMLCanvasElement","SVGImageElement","OffscreenCanvas","ImageBitmap","File","Blob","URL","src","createObjectURL","toString","revokeObjectURL","complete","naturalWidth","ErrorEvent","_workerMessageId","postMessage","type"],"sources":["D:\\Revels\\Revels\\frontend\\node_modules\\qr-scanner\\src\\qr-scanner.ts"],"sourcesContent":["class QrScanner {\n    static readonly DEFAULT_CANVAS_SIZE = 400;\n    static readonly NO_QR_CODE_FOUND = 'No QR code found';\n    private static _disableBarcodeDetector = false;\n    private static _workerMessageId = 0;\n\n    /** @deprecated */\n    static set WORKER_PATH(workerPath: string) {\n        console.warn('Setting QrScanner.WORKER_PATH is not required and not supported anymore. '\n            + 'Have a look at the README for new setup instructions.');\n    }\n\n    static async hasCamera(): Promise<boolean> {\n        try {\n            return !!(await QrScanner.listCameras(false)).length;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    static async listCameras(requestLabels = false): Promise<Array<QrScanner.Camera>> {\n        if (!navigator.mediaDevices) return [];\n\n        const enumerateCameras = async (): Promise<Array<MediaDeviceInfo>> =>\n            (await navigator.mediaDevices.enumerateDevices()).filter((device) => device.kind === 'videoinput');\n\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n        // or permission to access the camera was given. Therefore, if we're not getting labels but labels are requested\n        // ask for camera permission by opening a stream.\n        let openedStream: MediaStream | undefined;\n        try {\n            if (requestLabels && (await enumerateCameras()).every((camera) => !camera.label)) {\n                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n            }\n        } catch (e) {\n            // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in use\n            // and some browsers disallow a second stream.\n        }\n\n        try {\n            return (await enumerateCameras()).map((camera, i) => ({\n                id: camera.deviceId,\n                label: camera.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\n            }));\n        } finally {\n            // close the stream we just opened for getting camera access for listing the device labels\n            if (openedStream) {\n                console.warn('Call listCameras after successfully starting a QR scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(openedStream);\n            }\n        }\n    }\n\n    readonly $video: HTMLVideoElement;\n    readonly $canvas: HTMLCanvasElement;\n    readonly $overlay?: HTMLDivElement;\n    private readonly $codeOutlineHighlight?: SVGSVGElement;\n    private readonly _onDecode?: (result: QrScanner.ScanResult) => void;\n    private readonly _legacyOnDecode?: (result: string) => void;\n    private readonly _legacyCanvasSize: number = QrScanner.DEFAULT_CANVAS_SIZE;\n    private _preferredCamera: QrScanner.FacingMode | QrScanner.DeviceId = 'environment';\n    private readonly _maxScansPerSecond: number = 25;\n    private _lastScanTimestamp: number = -1;\n    private _scanRegion: QrScanner.ScanRegion;\n    private _codeOutlineHighlightRemovalTimeout?: number;\n    private _qrEnginePromise: Promise<Worker | BarcodeDetector>\n    private _active: boolean = false;\n    private _paused: boolean = false;\n    private _flashOn: boolean = false;\n    private _destroyed: boolean = false;\n\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: QrScanner.ScanResult) => void,\n        options: {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        canvasSize?: number,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(video: HTMLVideoElement, onDecode: (result: string) => void, canvasSize?: number);\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: ((result: QrScanner.ScanResult) => void) | ((result: string) => void),\n        canvasSizeOrOnDecodeErrorOrOptions?: number | ((error: Error | string) => void) | {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n        canvasSizeOrCalculateScanRegion?: number | ((video: HTMLVideoElement) => QrScanner.ScanRegion),\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n\n        if (canvasSizeOrOnDecodeErrorOrOptions && typeof canvasSizeOrOnDecodeErrorOrOptions === 'object') {\n            // we got an options object using the new api\n            this._onDecode = onDecode as QrScanner['_onDecode'];\n        } else {\n            if (canvasSizeOrOnDecodeErrorOrOptions || canvasSizeOrCalculateScanRegion || preferredCamera) {\n                console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                    + 'the future');\n            } else {\n                // Only video and onDecode were specified and we can't distinguish between new or old api usage. For\n                // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n                // optional in the parameter list above to make clear that ScanResult instead of string is only passed\n                // if an options object was provided. However, in the future once legacy support is removed, the options\n                // object should become optional.\n                console.warn('Note that the type of the scan result passed to onDecode will change in the future. '\n                    + 'To already switch to the new api today, you can pass returnDetailedScanResult: true.');\n            }\n            this._legacyOnDecode = onDecode as QrScanner['_legacyOnDecode'];\n        }\n\n        const options = typeof canvasSizeOrOnDecodeErrorOrOptions === 'object'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : {};\n        this._onDecodeError = options.onDecodeError || (typeof canvasSizeOrOnDecodeErrorOrOptions === 'function'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : this._onDecodeError);\n        this._calculateScanRegion = options.calculateScanRegion || (typeof canvasSizeOrCalculateScanRegion==='function'\n            ? canvasSizeOrCalculateScanRegion\n            : this._calculateScanRegion);\n        this._preferredCamera = options.preferredCamera || preferredCamera || this._preferredCamera;\n        this._legacyCanvasSize = typeof canvasSizeOrOnDecodeErrorOrOptions === 'number'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : typeof canvasSizeOrCalculateScanRegion === 'number'\n                ? canvasSizeOrCalculateScanRegion\n                : this._legacyCanvasSize;\n        this._maxScansPerSecond = options.maxScansPerSecond || this._maxScansPerSecond;\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n        this._updateOverlay = this._updateOverlay.bind(this);\n\n        // @ts-ignore\n        video.disablePictureInPicture = true;\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        // @ts-ignore\n        video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        video.muted = true;\n\n        // Avoid Safari stopping the video stream on a hidden video.\n        // See https://github.com/cozmo/jsQR/issues/185\n        let shouldHideVideo = false;\n        if (video.hidden) {\n            video.hidden = false;\n            shouldHideVideo = true;\n        }\n        if (!document.body.contains(video)) {\n            document.body.appendChild(video);\n            shouldHideVideo = true;\n        }\n        const videoContainer = video.parentElement!;\n\n        if (options.highlightScanRegion || options.highlightCodeOutline) {\n            const gotExternalOverlay = !!options.overlay;\n            this.$overlay = options.overlay || document.createElement('div');\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.position = 'absolute';\n            overlayStyle.display = 'none';\n            overlayStyle.pointerEvents = 'none';\n            this.$overlay.classList.add('scan-region-highlight');\n            if (!gotExternalOverlay && options.highlightScanRegion) {\n                // default style; can be overwritten via css, e.g. by changing the svg's stroke color, hiding the\n                // .scan-region-highlight-svg, setting a border, outline, background, etc.\n                this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" '\n                    + 'preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;'\n                    + 'fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\">'\n                    + '<path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 '\n                    + '0H10a8 8 0 0 1-8-8v-21\"/></svg>';\n                try {\n                    this.$overlay.firstElementChild!.animate({ transform: ['scale(.98)', 'scale(1.01)'] }, {\n                        duration: 400,\n                        iterations: Infinity,\n                        direction: 'alternate',\n                        easing: 'ease-in-out',\n                    });\n                } catch (e) {}\n                videoContainer.insertBefore(this.$overlay, this.$video.nextSibling);\n            }\n            if (options.highlightCodeOutline) {\n                // default style; can be overwritten via css\n                this.$overlay.insertAdjacentHTML(\n                    'beforeend',\n                    '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;'\n                        + 'height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;'\n                        + 'stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>',\n                );\n                this.$codeOutlineHighlight = this.$overlay.lastElementChild as SVGSVGElement;\n            }\n        }\n        this._scanRegion = this._calculateScanRegion(video);\n\n        requestAnimationFrame(() => {\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n            const videoStyle = window.getComputedStyle(video);\n            if (videoStyle.display === 'none') {\n                video.style.setProperty('display', 'block', 'important');\n                shouldHideVideo = true;\n            }\n            if (videoStyle.visibility !== 'visible') {\n                video.style.setProperty('visibility', 'visible', 'important');\n                shouldHideVideo = true;\n            }\n            if (shouldHideVideo) {\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n                video.style.opacity = '0';\n                video.style.width = '0';\n                video.style.height = '0';\n                if (this.$overlay && this.$overlay.parentElement) {\n                    this.$overlay.parentElement.removeChild(this.$overlay);\n                }\n                // @ts-ignore\n                delete this.$overlay!;\n                // @ts-ignore\n                delete this.$codeOutlineHighlight!;\n            }\n\n            if (this.$overlay) {\n                this._updateOverlay();\n            }\n        });\n\n        video.addEventListener('play', this._onPlay);\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n        window.addEventListener('resize', this._updateOverlay);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    async hasFlash(): Promise<boolean> {\n        let stream: MediaStream | undefined;\n        try {\n            if (this.$video.srcObject) {\n                if (!(this.$video.srcObject instanceof MediaStream)) return false; // srcObject is not a camera stream\n                stream = this.$video.srcObject;\n            } else {\n                stream = (await this._getCameraStream()).stream;\n            }\n            return 'torch' in stream.getVideoTracks()[0].getSettings();\n        } catch (e) {\n            return false;\n        } finally {\n            // close the stream we just opened for detecting whether it supports flash\n            if (stream && stream !== this.$video.srcObject) {\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(stream);\n            }\n        }\n    }\n\n    isFlashOn(): boolean {\n        return this._flashOn;\n    }\n\n    async toggleFlash(): Promise<void> {\n        if (this._flashOn) {\n            await this.turnFlashOff();\n        } else {\n            await this.turnFlashOn();\n        }\n    }\n\n    async turnFlashOn(): Promise<void> {\n        if (this._flashOn || this._destroyed) return;\n        this._flashOn = true;\n        if (!this._active || this._paused) return; // flash will be turned on later on .start()\n        try {\n            if (!await this.hasFlash()) throw 'No flash available';\n            // Note that the video track is guaranteed to exist and to be a MediaStream due to the check in hasFlash\n            await (this.$video.srcObject as MediaStream).getVideoTracks()[0].applyConstraints({\n                // @ts-ignore: constraint 'torch' is unknown to ts\n                advanced: [{ torch: true }],\n            });\n        } catch (e) {\n            this._flashOn = false;\n            throw e;\n        }\n    }\n\n    async turnFlashOff(): Promise<void> {\n        if (!this._flashOn) return;\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n        // we have to stop the stream to turn the flashlight off.\n        this._flashOn = false;\n        await this._restartVideoStream();\n    }\n\n    destroy(): void {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n        window.removeEventListener('resize', this._updateOverlay);\n\n        this._destroyed = true;\n        this._flashOn = false;\n        this.stop(); // sets this._paused = true and this._active = false\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    async start(): Promise<void> {\n        if (this._destroyed) throw new Error('The QR scanner can not be started as it had been destroyed.');\n        if (this._active && !this._paused) return;\n\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n\n        this._active = true;\n        if (document.hidden) return; // camera will be started as soon as tab is in foreground\n        this._paused = false;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            await this.$video.play();\n            return;\n        }\n\n        try {\n            const { stream, facingMode } = await this._getCameraStream();\n            if (!this._active || this._paused) {\n                // was stopped in the meantime\n                QrScanner._stopVideoStream(stream);\n                return;\n            }\n            this._setVideoMirror(facingMode);\n            this.$video.srcObject = stream;\n            await this.$video.play();\n\n            // Restart the flash if it was previously on\n            if (this._flashOn) {\n                this._flashOn = false; // force turnFlashOn to restart the flash\n                this.turnFlashOn().catch(() => {});\n            }\n        } catch (e) {\n            if (this._paused) return;\n            this._active = false;\n            throw e;\n        }\n    }\n\n    stop(): void {\n        this.pause();\n        this._active = false;\n    }\n\n    async pause(stopStreamImmediately = false): Promise<boolean> {\n        this._paused = true;\n        if (!this._active) return true;\n        this.$video.pause();\n\n        if (this.$overlay) {\n            this.$overlay.style.display = 'none';\n        }\n\n        const stopStream = () => {\n            if (this.$video.srcObject instanceof MediaStream) {\n                // revoke srcObject only if it's a stream which was likely set by us\n                QrScanner._stopVideoStream(this.$video.srcObject);\n                this.$video.srcObject = null;\n            }\n        };\n\n        if (stopStreamImmediately) {\n            stopStream();\n            return true;\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if (!this._paused) return false;\n        stopStream();\n        return true;\n    }\n\n    async setCamera(facingModeOrDeviceId: QrScanner.FacingMode | QrScanner.DeviceId): Promise<void> {\n        if (facingModeOrDeviceId === this._preferredCamera) return;\n        this._preferredCamera = facingModeOrDeviceId;\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n        await this._restartVideoStream();\n    }\n\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        options: {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    ): Promise<QrScanner.ScanResult>;\n    /** @deprecated */\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegion?: QrScanner.ScanRegion | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing?: boolean,\n        alsoTryWithoutScanRegion?: boolean,\n    ): Promise<string>;\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegionOrOptions?: QrScanner.ScanRegion | {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        } | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing: boolean = false,\n        alsoTryWithoutScanRegion: boolean = false,\n    ): Promise<string | QrScanner.ScanResult> {\n        let scanRegion: QrScanner.ScanRegion | null | undefined;\n        let returnDetailedScanResult = false;\n        if (scanRegionOrOptions && (\n            'scanRegion' in scanRegionOrOptions\n            || 'qrEngine' in scanRegionOrOptions\n            || 'canvas' in scanRegionOrOptions\n            || 'disallowCanvasResizing' in scanRegionOrOptions\n            || 'alsoTryWithoutScanRegion' in scanRegionOrOptions\n            || 'returnDetailedScanResult' in scanRegionOrOptions\n        )) {\n            // we got an options object using the new api\n            scanRegion = scanRegionOrOptions.scanRegion;\n            qrEngine = scanRegionOrOptions.qrEngine;\n            canvas = scanRegionOrOptions.canvas;\n            disallowCanvasResizing = scanRegionOrOptions.disallowCanvasResizing || false;\n            alsoTryWithoutScanRegion = scanRegionOrOptions.alsoTryWithoutScanRegion || false;\n            returnDetailedScanResult = true;\n        } else if (scanRegionOrOptions || qrEngine || canvas || disallowCanvasResizing || alsoTryWithoutScanRegion) {\n            console.warn('You\\'re using a deprecated api for scanImage which will be removed in the future.');\n        } else {\n            // Only imageOrFileOrBlobOrUrl was specified and we can't distinguish between new or old api usage. For\n            // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n            // optional in the parameter list above to make clear that ScanResult instead of string is only returned if\n            // an options object was provided. However, in the future once legacy support is removed, the options object\n            // should become optional.\n            console.warn('Note that the return type of scanImage will change in the future. To already switch to the '\n                + 'new api today, you can pass returnDetailedScanResult: true.');\n        }\n\n        const gotExternalEngine = !!qrEngine;\n\n        try {\n            let image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n                | SVGImageElement;\n            let canvasContext: CanvasRenderingContext2D;\n            [qrEngine, image] = await Promise.all([\n                qrEngine || QrScanner.createQrEngine(),\n                QrScanner._loadImage(imageOrFileOrBlobOrUrl),\n            ]);\n            [canvas, canvasContext] = QrScanner._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n            let detailedScanResult: QrScanner.ScanResult;\n\n            if (qrEngine instanceof Worker) {\n                const qrEngineWorker = qrEngine; // for ts to know that it's still a worker later in the event listeners\n                if (!gotExternalEngine) {\n                    // Enable scanning of inverted color qr codes.\n                    QrScanner._postWorkerMessageSync(qrEngineWorker, 'inversionMode', 'both');\n                }\n                detailedScanResult = await new Promise((resolve, reject) => {\n                    let timeout: number;\n                    let onMessage: (event: MessageEvent) => void;\n                    let onError: (error: ErrorEvent | string) => void;\n                    let expectedResponseId = -1;\n                    onMessage = (event: MessageEvent) => {\n                        if (event.data.id !== expectedResponseId) {\n                            return;\n                        }\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve({\n                                data: event.data.data,\n                                cornerPoints: QrScanner._convertPoints(event.data.cornerPoints, scanRegion),\n                            });\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (error: ErrorEvent | string) => {\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !error ? 'Unknown Error' : ((error as ErrorEvent).message || error);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngineWorker.addEventListener('message', onMessage);\n                    qrEngineWorker.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas!.width, canvas!.height);\n                    expectedResponseId = QrScanner._postWorkerMessageSync(\n                        qrEngineWorker,\n                        'decode',\n                        imageData,\n                        [imageData.data.buffer],\n                    );\n                });\n            } else {\n                detailedScanResult = await Promise.race([\n                    new Promise<QrScanner.ScanResult>((resolve, reject) => window.setTimeout(\n                        () => reject('Scanner error: timeout'),\n                        10000,\n                    )),\n                    (async (): Promise<QrScanner.ScanResult> => {\n                        try {\n                            const [scanResult] = await qrEngine.detect(canvas!);\n                            if (!scanResult) throw QrScanner.NO_QR_CODE_FOUND;\n                            return {\n                                data: scanResult.rawValue,\n                                cornerPoints: QrScanner._convertPoints(scanResult.cornerPoints, scanRegion),\n                            };\n                        } catch (e) {\n                            const errorMessage = (e as Error).message || e as string;\n                            if (/not implemented|service unavailable/.test(errorMessage)) {\n                                // Not implemented can apparently for some reason happen even though getSupportedFormats\n                                // in createQrScanner reported that it's supported, see issue #98.\n                                // Service unavailable can happen after some time when the BarcodeDetector crashed and\n                                // can theoretically be recovered from by creating a new BarcodeDetector. However, in\n                                // newer browsers this issue does not seem to be present anymore and therefore we do not\n                                // apply this optimization anymore but just set _disableBarcodeDetector in both cases.\n                                // Also note that if we got an external qrEngine that crashed, we should possibly notify\n                                // the caller about it, but we also don't do this here, as it's such an unlikely case.\n                                QrScanner._disableBarcodeDetector = true;\n                                // retry without passing the broken BarcodeScanner instance\n                                return QrScanner.scanImage(imageOrFileOrBlobOrUrl, {\n                                    scanRegion,\n                                    canvas,\n                                    disallowCanvasResizing,\n                                    alsoTryWithoutScanRegion,\n                                });\n                            }\n                            throw `Scanner error: ${errorMessage}`;\n                        }\n                    })(),\n                ]);\n            }\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } catch (e) {\n            if (!scanRegion || !alsoTryWithoutScanRegion) throw e;\n            const detailedScanResult = await QrScanner.scanImage(\n                imageOrFileOrBlobOrUrl,\n                { qrEngine, canvas, disallowCanvasResizing },\n            );\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } finally {\n            if (!gotExternalEngine) {\n                QrScanner._postWorkerMessage(qrEngine!, 'close');\n            }\n        }\n    }\n\n    setGrayscaleWeights(red: number, green: number, blue: number, useIntegerApproximation: boolean = true): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations work also well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode: QrScanner.InversionMode): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations scan normal and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    static async createQrEngine(): Promise<Worker | BarcodeDetector>;\n    /** @deprecated */\n    static async createQrEngine(workerPath: string): Promise<Worker | BarcodeDetector>;\n    static async createQrEngine(workerPath?: string): Promise<Worker | BarcodeDetector> {\n        if (workerPath) {\n            console.warn('Specifying a worker path is not required and not supported anymore.');\n        }\n\n        // @ts-ignore no types defined for import\n        const createWorker = () => (import('./qr-scanner-worker.min.js') as Promise<{ createWorker: () => Worker }>)\n            .then((module) => module.createWorker());\n\n        const useBarcodeDetector = !QrScanner._disableBarcodeDetector\n            && 'BarcodeDetector' in window\n            && BarcodeDetector.getSupportedFormats\n            && (await BarcodeDetector.getSupportedFormats()).includes('qr_code');\n\n        if (!useBarcodeDetector) return createWorker();\n\n        // On Macs with an M1/M2 processor and macOS Ventura (macOS version 13), the BarcodeDetector is broken in\n        // Chromium based browsers, regardless of the version. For that constellation, the BarcodeDetector does not\n        // error but does not detect QR codes. Macs without an M1/M2 or before Ventura are fine.\n        // See issue #209 and https://bugs.chromium.org/p/chromium/issues/detail?id=1382442\n        // TODO update this once the issue in macOS is fixed\n        const userAgentData = navigator.userAgentData;\n        const isChromiumOnMacWithArmVentura = userAgentData // all Chromium browsers support userAgentData\n            && userAgentData.brands.some(({ brand }) => /Chromium/i.test(brand))\n            && /mac ?OS/i.test(userAgentData.platform)\n            // Does it have an ARM chip (e.g. M1/M2) and Ventura? Check this last as getHighEntropyValues can\n            // theoretically trigger a browser prompt, although no browser currently does seem to show one.\n            // If browser or user refused to return the requested values, assume broken ARM Ventura, to be safe.\n            && await userAgentData.getHighEntropyValues(['architecture', 'platformVersion'])\n                .then(({ architecture, platformVersion }) =>\n                    /arm/i.test(architecture || 'arm') && parseInt(platformVersion || '13') >= /* Ventura */ 13)\n                .catch(() => true);\n        if (isChromiumOnMacWithArmVentura) return createWorker();\n\n        return new BarcodeDetector({ formats: ['qr_code'] });\n    }\n\n    private _onPlay(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n        if (this.$overlay) {\n            this.$overlay.style.display = '';\n        }\n        this._scanFrame();\n    }\n\n    private _onLoadedMetaData(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n    }\n\n    private _onVisibilityChange(): void {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    private _calculateScanRegion(video: HTMLVideoElement): QrScanner.ScanRegion {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    private _updateOverlay(): void {\n        requestAnimationFrame(() => {\n            // Running in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle\n            // and offsetWidth, offsetHeight, offsetLeft, offsetTop.\n            if (!this.$overlay) return;\n            const video = this.$video;\n            const videoWidth = video.videoWidth;\n            const videoHeight = video.videoHeight;\n            const elementWidth = video.offsetWidth;\n            const elementHeight = video.offsetHeight;\n            const elementX = video.offsetLeft;\n            const elementY = video.offsetTop;\n\n            const videoStyle = window.getComputedStyle(video);\n            const videoObjectFit = videoStyle.objectFit;\n            const videoAspectRatio = videoWidth / videoHeight;\n            const elementAspectRatio = elementWidth / elementHeight;\n            let videoScaledWidth: number;\n            let videoScaledHeight: number;\n            switch (videoObjectFit) {\n                case 'none':\n                    videoScaledWidth = videoWidth;\n                    videoScaledHeight = videoHeight;\n                    break;\n                case 'fill':\n                    videoScaledWidth = elementWidth;\n                    videoScaledHeight = elementHeight;\n                    break;\n                default: // 'cover', 'contains', 'scale-down'\n                    if (videoObjectFit === 'cover'\n                        ? videoAspectRatio > elementAspectRatio\n                        : videoAspectRatio < elementAspectRatio) {\n                        // The scaled height is the element height\n                        // - for 'cover' if the video aspect ratio is wider than the element aspect ratio\n                        //   (scaled height matches element height and scaled width overflows element width)\n                        // - for 'contains'/'scale-down' if element aspect ratio is wider than the video aspect ratio\n                        //   (scaled height matched element height and element width overflows scaled width)\n                        videoScaledHeight = elementHeight;\n                        videoScaledWidth = videoScaledHeight * videoAspectRatio;\n                    } else {\n                        videoScaledWidth = elementWidth;\n                        videoScaledHeight = videoScaledWidth / videoAspectRatio;\n                    }\n                    if (videoObjectFit === 'scale-down') {\n                        // for 'scale-down' the dimensions are the minimum of 'contains' and 'none'\n                        videoScaledWidth = Math.min(videoScaledWidth, videoWidth);\n                        videoScaledHeight = Math.min(videoScaledHeight, videoHeight);\n                    }\n            }\n\n            // getComputedStyle is so nice to convert keywords (left, center, right, top, bottom) to percent and makes\n            // sure to set the default of 50% if only one or no component was provided, therefore we can be sure that\n            // both components are set. Additionally, it converts units other than px (e.g. rem) to px.\n            const [videoX, videoY] = videoStyle.objectPosition.split(' ').map((length, i) => {\n                const lengthValue = parseFloat(length);\n                return length.endsWith('%')\n                    ? (!i ? elementWidth - videoScaledWidth : elementHeight - videoScaledHeight) * lengthValue / 100\n                    : lengthValue;\n            });\n\n            const regionWidth = this._scanRegion.width || videoWidth;\n            const regionHeight = this._scanRegion.height || videoHeight;\n            const regionX = this._scanRegion.x || 0;\n            const regionY = this._scanRegion.y || 0;\n\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.width = `${regionWidth / videoWidth * videoScaledWidth}px`;\n            overlayStyle.height = `${regionHeight / videoHeight * videoScaledHeight}px`;\n            overlayStyle.top = `${elementY + videoY + regionY / videoHeight * videoScaledHeight}px`;\n            const isVideoMirrored = /scaleX\\(-1\\)/.test(video.style.transform!);\n            overlayStyle.left = `${elementX\n                + (isVideoMirrored ? elementWidth - videoX - videoScaledWidth : videoX)\n                + (isVideoMirrored ? videoWidth - regionX - regionWidth : regionX) / videoWidth * videoScaledWidth}px`;\n            // apply same mirror as on video\n            overlayStyle.transform = video.style.transform;\n        });\n    }\n\n    private static _convertPoints(\n        points: QrScanner.Point[],\n        scanRegion?: QrScanner.ScanRegion | null,\n    ): QrScanner.Point[] {\n        if (!scanRegion) return points;\n        const offsetX = scanRegion.x || 0;\n        const offsetY = scanRegion.y || 0;\n        const scaleFactorX = scanRegion.width && scanRegion.downScaledWidth\n            ? scanRegion.width / scanRegion.downScaledWidth\n            : 1;\n        const scaleFactorY = scanRegion.height && scanRegion.downScaledHeight\n            ? scanRegion.height / scanRegion.downScaledHeight\n            : 1;\n        for (const point of points) {\n            point.x = point.x * scaleFactorX + offsetX;\n            point.y = point.y * scaleFactorY + offsetY;\n        }\n        return points;\n    }\n\n    private _scanFrame(): void {\n        if (!this._active || this.$video.paused || this.$video.ended) return;\n        // If requestVideoFrameCallback is available use that to avoid unnecessary scans on the same frame as the\n        // camera's framerate can be lower than the screen refresh rate and this._maxScansPerSecond, especially in dark\n        // settings where the exposure time is longer. Both, requestVideoFrameCallback and requestAnimationFrame are not\n        // being fired if the tab is in the background, which is what we want.\n        const requestFrame = 'requestVideoFrameCallback' in this.$video\n            // @ts-ignore\n            ? this.$video.requestVideoFrameCallback.bind(this.$video)\n            : requestAnimationFrame;\n        requestFrame(async () => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n\n            const timeSinceLastScan = Date.now() - this._lastScanTimestamp;\n            const minimumTimeBetweenScans = 1000 / this._maxScansPerSecond;\n            if (timeSinceLastScan < minimumTimeBetweenScans) {\n                await new Promise((resolve) => setTimeout(resolve, minimumTimeBetweenScans - timeSinceLastScan));\n            }\n            // console.log('Scan rate:', Math.round(1000 / (Date.now() - this._lastScanTimestamp)));\n            this._lastScanTimestamp = Date.now();\n\n            let result: QrScanner.ScanResult | undefined;\n            try {\n                result = await QrScanner.scanImage(this.$video, {\n                    scanRegion: this._scanRegion,\n                    qrEngine: this._qrEnginePromise,\n                    canvas: this.$canvas,\n                });\n            } catch (error) {\n                if (!this._active) return;\n                this._onDecodeError(error as Error | string);\n            }\n\n            if (QrScanner._disableBarcodeDetector && !(await this._qrEnginePromise instanceof Worker)) {\n                // replace the disabled BarcodeDetector\n                this._qrEnginePromise = QrScanner.createQrEngine();\n            }\n\n            if (result) {\n                if (this._onDecode) {\n                    this._onDecode(result);\n                } else if (this._legacyOnDecode) {\n                    this._legacyOnDecode(result.data);\n                }\n\n                if (this.$codeOutlineHighlight) {\n                    clearTimeout(this._codeOutlineHighlightRemovalTimeout);\n                    this._codeOutlineHighlightRemovalTimeout = undefined;\n                    this.$codeOutlineHighlight.setAttribute(\n                        'viewBox',\n                        `${this._scanRegion.x || 0} `\n                            + `${this._scanRegion.y || 0} `\n                            + `${this._scanRegion.width || this.$video.videoWidth} `\n                            + `${this._scanRegion.height || this.$video.videoHeight}`,\n                    );\n                    const polygon = this.$codeOutlineHighlight.firstElementChild!;\n                    polygon.setAttribute('points', result.cornerPoints.map(({x, y}) => `${x},${y}`).join(' '));\n                    this.$codeOutlineHighlight.style.display = '';\n                }\n            } else if (this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout) {\n                // hide after timeout to make it flash less when on some frames the QR code is detected and on some not\n                this._codeOutlineHighlightRemovalTimeout = setTimeout(\n                    () => this.$codeOutlineHighlight!.style.display = 'none',\n                    100,\n                );\n            }\n\n            this._scanFrame();\n        });\n    }\n\n    private _onDecodeError(error: Error | string): void {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    private async _getCameraStream(): Promise<{ stream: MediaStream, facingMode: QrScanner.FacingMode }> {\n        if (!navigator.mediaDevices) throw 'Camera not found.';\n\n        const preferenceType = /^(environment|user)$/.test(this._preferredCamera)\n            ? 'facingMode'\n            : 'deviceId';\n        const constraintsWithoutCamera: Array<MediaTrackConstraints> = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\n            [preferenceType]: { exact: this._preferredCamera },\n        }));\n\n        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });\n                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n                // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n                // mode, even for exact facingMode constraints.\n                const facingMode = this._getFacingMode(stream)\n                    || (constraints.facingMode\n                        ? this._preferredCamera as QrScanner.FacingMode // a facing mode we were able to fulfill\n                        : (this._preferredCamera === 'environment'\n                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n                            : 'environment' // switch from unfulfilled user facingMode or default to environment\n                        )\n                    );\n                return { stream, facingMode };\n            } catch (e) {}\n        }\n\n        throw 'Camera not found.';\n    }\n\n    private async _restartVideoStream(): Promise<void> {\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\n        const wasPaused = this._paused;\n        const paused = await this.pause(true);\n        if (!paused || wasPaused || !this._active) return;\n        await this.start();\n    }\n\n    private static _stopVideoStream(stream : MediaStream): void {\n        for (const track of stream.getTracks()) {\n            track.stop(); //  note that this will also automatically turn the flashlight off\n            stream.removeTrack(track);\n        }\n    }\n\n    private _setVideoMirror(facingMode: QrScanner.FacingMode): void {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode === 'user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    private _getFacingMode(videoStream: MediaStream): QrScanner.FacingMode | null {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    private static _drawToCanvas(\n        image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement,\n        scanRegion?: QrScanner.ScanRegion | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing= false,\n    ): [HTMLCanvasElement, CanvasRenderingContext2D] {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width\n            ? scanRegion.width\n            : (image as HTMLVideoElement).videoWidth || image.width as number;\n        const scanRegionHeight = scanRegion && scanRegion.height\n            ? scanRegion.height\n            : (image as HTMLVideoElement).videoHeight || image.height as number;\n\n        if (!disallowCanvasResizing) {\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\n                ? scanRegion.downScaledWidth\n                : scanRegionWidth;\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\n                ? scanRegion.downScaledHeight\n                : scanRegionHeight;\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n            // set them if they actually changed.\n            if (canvas.width !== canvasWidth) {\n                canvas.width = canvasWidth;\n            }\n            if (canvas.height !== canvasHeight) {\n                canvas.height = canvasHeight;\n            }\n        }\n\n        const context = canvas.getContext('2d', { alpha: false })!;\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height,\n        );\n        return [canvas, context];\n    }\n\n    private static async _loadImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n    ): Promise<HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n        | SVGImageElement > {\n        if (imageOrFileOrBlobOrUrl instanceof Image) {\n            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement\n            || imageOrFileOrBlobOrUrl instanceof SVGImageElement\n            || 'OffscreenCanvas' in window && imageOrFileOrBlobOrUrl instanceof OffscreenCanvas\n            || 'ImageBitmap' in window && imageOrFileOrBlobOrUrl instanceof ImageBitmap) {\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl.toString();\n            }\n            try {\n                await QrScanner._awaitImageLoad(image);\n                return image;\n            } finally {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n            }\n        } else {\n            throw 'Unsupported image type.';\n        }\n    }\n\n    private static async _awaitImageLoad(image: HTMLImageElement): Promise<void> {\n        if (image.complete && image.naturalWidth !== 0) return; // already loaded\n        await new Promise<void>((resolve, reject) => {\n            const listener = (event: ErrorEvent | Event) => {\n                image.removeEventListener('load', listener);\n                image.removeEventListener('error', listener);\n                if (event instanceof ErrorEvent) {\n                    reject('Image load error');\n                } else {\n                    resolve();\n                }\n            };\n            image.addEventListener('load', listener);\n            image.addEventListener('error', listener);\n        });\n    }\n\n    private static async _postWorkerMessage(\n        qrEngineOrQrEnginePromise: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector>,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): Promise<number> {\n        return QrScanner._postWorkerMessageSync(await qrEngineOrQrEnginePromise, type, data, transfer);\n    }\n\n    // sync version of _postWorkerMessage without performance overhead of async functions\n    private static _postWorkerMessageSync(\n        qrEngine: Worker | BarcodeDetector,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): number {\n        if (!(qrEngine instanceof Worker)) return -1;\n        const id = QrScanner._workerMessageId++;\n        qrEngine.postMessage({\n            id,\n            type,\n            data,\n        }, transfer);\n        return id;\n    }\n}\n\ndeclare namespace QrScanner {\n    export interface ScanRegion {\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        downScaledWidth?: number;\n        downScaledHeight?: number;\n    }\n\n    export type FacingMode = 'environment' | 'user';\n    export type DeviceId = string;\n\n    export interface Camera {\n        id: DeviceId;\n        label: string;\n    }\n\n    export type InversionMode = 'original' | 'invert' | 'both';\n\n    export interface Point {\n        x: number;\n        y: number;\n    }\n\n    export interface ScanResult {\n        data: string;\n        // In clockwise order, starting at top left, but this might not be guaranteed in the future.\n        cornerPoints: QrScanner.Point[];\n    }\n}\n\n// simplified from https://wicg.github.io/shape-detection-api/#barcode-detection-api\ndeclare class BarcodeDetector {\n    constructor(options?: { formats: string[] });\n    static getSupportedFormats(): Promise<string[]>;\n    detect(image: ImageBitmapSource): Promise<Array<{ rawValue: string, cornerPoints: QrScanner.Point[] }>>;\n}\n\n// simplified from https://github.com/lukewarlow/user-agent-data-types/blob/master/index.d.ts\ndeclare global {\n    interface Navigator {\n        readonly userAgentData?: {\n            readonly platform: string;\n            readonly brands: Array<{\n                readonly brand: string;\n                readonly version: string;\n            }>;\n            getHighEntropyValues(hints: string[]): Promise<{\n                readonly architecture?: string;\n                readonly platformVersion?: string;\n            }>;\n        };\n    }\n}\n\nexport default QrScanner;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}